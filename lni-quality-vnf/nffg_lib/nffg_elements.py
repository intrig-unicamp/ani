# Copyright 2017 Janos Czentye, Balazs Nemeth, Balazs Sonkoly
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at:
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
Classes for handling the elements of the NF-FG data structure.
"""
import json
import uuid
from collections import Iterable, OrderedDict
from itertools import chain


################################################################################
# ---------- BASE classes of NFFG elements -------------------
################################################################################

class Persistable(object):
  """
  Define general persist function for the whole NFFG structure.
  """

  def persist (self):
    """
    Common function to persist the actual element into a plain text format.

    :return: generated empty object fit to JSON
    :rtype: dict
    """
    return OrderedDict()

  def load (self, data, *args, **kwargs):
    """
    Common function to fill self with data from JSON data.

    :raise: :any:`exceptions.NotImplementedError`
    :param data: object structure in JSON
    :return: self
    """
    pass

  @classmethod
  def parse (cls, data, *args, **kwargs):
    """
    Common function to parse the given JSON object structure as the actual NF-FG
    entity type and return a newly created object.

    :param data: raw JSON object structure
    :type data: object
    :return: parsed data as the entity type
    :rtype: :any:`Persistable`
    """
    return cls().load(data, *args, **kwargs)


class Element(Persistable):
  """
  Main base class for NF-FG elements with unique id.

  Contains the common functionality.
  """
  # Operation constants
  OP_CREATE = "create"
  OP_REPLACE = "replace"
  OP_MERGE = "merge"
  OP_REMOVE = "remove"
  OP_DELETE = "delete"
  # Status constants
  STATUS_INIT = "INITIALIZED"
  STATUS_PENDING = "PENDING"
  STATUS_DEPLOY = "DEPLOYED"
  STATUS_RUN = "RUNNING"
  STATUS_STOP = "STOPPED"
  STATUS_FAIL = "FAILED"

  def __init__ (self, id=None, type="ELEMENT", operation=None, status=None):
    """
    Init.

    :param id: optional identification (generated by default)
    :type id: str or int
    :param type: explicit object type both for nodes and edges
    :type type: str
    :return: None
    """
    super(Element, self).__init__()
    self.id = id if id is not None else self.generate_unique_id()
    self.type = type
    self.operation = operation
    self.status = status

  @staticmethod
  def generate_unique_id ():
    """
    Generate a unique id for the object based on uuid module: :rfc:`4122`.

    :return: unique id
    :rtype: str
    """
    return str(uuid.uuid1())

  def regenerate_id (self):
    """
    Regenerate and set id. Useful for object copy.

    :return: new id
    :rtype: str
    """
    self.id = self.generate_unique_id()
    return self.id

  def persist (self):
    """
    Persist object.

    :return: JSON representation
    :rtype: dict
    """
    # Need to override
    element = super(Element, self).persist()
    element['id'] = self.id
    if self.operation is not None:
      element["operation"] = self.operation
    if self.status is not None:
      element["status"] = self.status
    return element

  def load (self, data, *args, **kwargs):
    """
    Instantiate object from JSON.

    :param data: JSON data
    :type data: dict
    :return: None
    """
    self.id = data['id']
    super(Element, self).load(data=data)
    self.operation = data.get("operation")  # optional
    self.status = data.get("status")  # optional
    return self

  def copy (self):
    """
    Return the copy of the object.

    :return: copied object
    :rtype: :any:`Element`
    """
    from copy import deepcopy
    return deepcopy(self)

  def dump (self):
    """
    Dump the Element in a pretty format for debugging.

    :return: Element in JSON format
    :rtype: str
    """
    return json.dumps(self.persist(), indent=2, sort_keys=False)

  ##############################################################################
  # dict specific functions
  ##############################################################################

  def __getitem__ (self, item):
    """
    Return the attribute of the element given by ``item``.

    :param item: attribute name
    :type item: str or int
    :return: attribute
    :rtype: object
    """
    if hasattr(self, item):
      return getattr(self, item)
    else:
      raise KeyError(
        "%s object has no key: %s" % (self.__class__.__name__, item))

  def __setitem__ (self, key, value):
    """
    Set the attribute given by ``key`` with ``value``:

    :param key: attribute name
    :type key: str or int
    :param value: new value
    :type value: object
    :return: new value
    :rtype: object
    """
    if hasattr(self, key):
      return setattr(self, key, value)
    else:
      raise KeyError(
        "%s object has no key: %s" % (self.__class__.__name__, key))

  def __contains__ (self, item):
    """
    Return true if the given ``item`` is exist.

    :param item: searched attribute name
    :type item: str or int
    :return: given item is exist or not
    :rtype: bool
    """
    return hasattr(self, item)

  def get (self, item, default=None):
    """
    Return with the attribute given by ``item``, else ``default``.

    :param item: searched attribute name
    :type item: str
    :param default: default value
    :type default: object
    :return: found attribute or default
    :rtype: object
    """
    try:
      return self[item]
    except KeyError:
      return default

  def setdefault (self, key, default=None):
    """
    Set the attribute given by ``key``. Use the ``default`` value is it is
    not given.

    :param key: attribute name
    :type key: str or int
    :param default: default value
    :type default: object
    :return: None
    """
    if key not in self:
      self[key] = default

  def clear (self):
    """
    Overrided for safety reasons.

    :raise: :any:`exceptions.RuntimeError`
    """
    raise RuntimeError("This standard dict functions is not supported by NFFG!")

  def update (self, dict2):
    """
    Overrided for safety reasons.

    :raise: :any:`exceptions.RuntimeError`
    """
    raise RuntimeError(
      "This standard dict functions is not supported by NFFG! self: %s dict2: "
      "%s" % (self, dict2))


class L3Address(Element):
  """
  Wrapper class for storing L3 address values.
  """

  def __init__ (self, id, name=None, configure=None, client=None,
                requested=None, provided=None):
    """
    Init.

    :param id: optional id
    :type id: str or int
    :param name: optional name
    :type name: str
    :param configure: request address
    :type configure: bool
    :param client: client of the address request
    :type client: str
    :param requested: requested IP
    :type requested: str
    :param provided: provided IP
    :type provided: str
    :return: None
    """
    super(L3Address, self).__init__(id=id, type="L3ADDRESS")
    self.name = name
    self.configure = configure
    self.client = client
    self.requested = requested
    self.provided = provided

  def load (self, data, *args, **kwargs):
    """
    Instantiate object from JSON.

    :param data: JSON data
    :type data: dict
    :return: None
    """
    super(L3Address, self).load(data=data)
    self.name = data.get('name')
    self.configure = data.get('configure')
    self.requested = data.get('requested')
    self.provided = data.get('provided')
    return self

  def persist (self):
    """
    Persist object.

    :return: JSON representation
    :rtype: dict
    """
    l3 = super(L3Address, self).persist()
    if self.name is not None:
      l3['name'] = self.name
    if self.configure is not None:
      l3['configure'] = self.configure
    if self.client is not None:
      l3['client'] = self.client
    if self.requested is not None:
      l3['requested'] = self.requested
    if self.provided is not None:
      l3['provided'] = self.provided
    return l3


class L3AddressContainer(Persistable):
  """
  Container class for storing L3 address data.
  """

  def __init__ (self, container=None):
    """
    Init.

    :param container: optional container for L3 addresses.
    :type container: collection.Iterable
    :return: None
    """
    super(L3AddressContainer, self).__init__()
    self.container = container if container is not None else []

  def __getitem__ (self, id):
    """
    Return with the :any:`L3Address` given by ``id``.

    :param id: L3 address id
    :type id: str or int
    :return: L3 address
    :rtype: :any:`L3Address`
    """
    for l3 in self.container:
      if l3.id == id:
        return l3
    raise KeyError("L3 address with id: %s is not defined!" % id)

  def __iter__ (self):
    """
    Return with an iterator over the container.

    :return: iterator
    :rtype: collection.Iterable
    """
    return iter(self.container)

  def __len__ (self):
    """
    Return the number of stored :any:`L3Address`.

    :return: number of addresses
    :rtype: int
    """
    return len(self.container)

  def __contains__ (self, item):
    """
    Return True if address given by ``id`` is exist in the container.

    :param item: address object
    :type: :any:`L3Address`
    :return: found address or not
    :rtype: bool
    """
    if not isinstance(item, L3Address):
      raise RuntimeError(
        "L3AddressContainer's operator \"in\" works only with L3Address "
        "objects (and not ID-s!)")
    return item in self.container

  def append (self, item):
    """
    Add a new address to the container.

    :param item: address object
    :type: :any:`L3Address`
    :return: added address
    :rtype: :any:`L3Address`
    """
    self.container.append(item)
    return item

  def remove (self, item):
    """
    Remove L3 address from container.

    :param item: address object
    :type: :any:`L3Address`
    :return: removed address
    :rtype: :any:`L3Address`
    """
    return self.container.remove(item)

  def clear (self):
    """
    Remove all the stored address from container.

    :return: None
    """
    del self.container[:]

  def __str__ (self):
    """
    Return with string representation.

    :return: string representation
    :rtype: str
    """
    return str(self.container)

  def __repr__ (self):
    """
    Return with specific string representation.

    :return: specific representation
    :rtype: str
    """
    return str(self)

  def add_l3address (self, id, name=None, configure=None, client=None,
                     requested=None, provided=None):
    """
    Add a new address to the container based on given :any:`L3Address`
    attributes.

    :param id: optional id
    :type id: str or int
    :param name: optional name
    :type name: str
    :param configure: request address
    :type configure: bool
    :param client: client of the address request
    :type client: str
    :param requested: requested IP
    :type requested: str
    :param provided: provided IP
    :type provided: str
    :return: None
    """
    self.container.append(
      L3Address(id, name=name, configure=configure, client=client,
                requested=requested, provided=provided))

  def persist (self):
    """
    Persist object.

    :return: JSON representation
    :rtype: list
    """
    return [l3.persist() for l3 in self.container]

  def load (self, data, *args, **kwargs):
    """
    Instantiate object from JSON.

    :param data: JSON data
    :type data: dict
    :return: None
    """
    for item in data:
      self.add_l3address(id=item['id'], name=item.get('name'),
                         configure=item.get('configure'),
                         client=item.get('client'),
                         requested=item.get('requested'),
                         provided=item.get('provided'))


class Port(Element):
  """
  Class for storing a port of an NF.
  """
  # Port type
  TYPE = "PORT"
  """Port type"""
  ROLE_CONSUMER = "consumer"
  ROLE_PROVIDER = "provider"

  def __init__ (self, node, id=None, name=None, properties=None, sap=None,
                capability=None, technology=None, role=None, delay=None,
                bandwidth=None, cost=None, controller=None, orchestrator=None,
                l2=None, l4=None, metadata=None):
    """
    Init.

    :param node: container node
    :type node: :any:`Node`
    :param id: optional id
    :type id: str or int
    :param properties: supported properties of the port
    :type properties: str or iterable(str)
    :param name: optional name
    :type name: str
    :param name: optional capabilities
    :type name: str
    :param sap: inter-domain SAP identifier
    :type sap: str
    :param technology: supported technologies
    :type technology: str
    :param delay: delay
    :type delay: float
    :param bandwidth: bandwidth
    :type bandwidth: float
    :param cost: cost
    :type cost: str
    :param controller: controller URL
    :type controller: str
    :param orchestrator: orchestrator URL
    :type orchestrator: str
    :param l2: l2 address
    :param l2: str
    :param l4: l4 fields
    :type l4: str
    :param metadata: metadata related to Node
    :type metadata: dict
    :return: None
    """
    super(Port, self).__init__(id=id, type=self.TYPE)
    if not isinstance(node, Node):
      raise RuntimeError("Port's container node must be derived from Node!")
    # weakref to avoid circular reference
    # weakref causes some really annoying issue --> changed to normal ref
    # self.__node = weakref.ref(node)
    self.__node = node
    # Set properties list according to given param type
    self.properties = OrderedDict(properties if properties else {})
    self.metadata = OrderedDict(metadata if metadata else {})
    # Virtualizer-related data
    self.name = name
    self.sap = sap
    self.capability = capability
    # sap_data
    self.technology = technology
    # sap_data/role
    self.role = role
    # sap_data/resources
    self.delay = delay
    self.bandwidth = bandwidth
    self.cost = cost
    # control
    self.controller = controller
    self.orchestrator = orchestrator
    # addresses
    self.l2 = l2
    self.l3 = L3AddressContainer()
    self.l4 = l4

  @property
  def node (self):
    """
    Return with the container reference.

    :return: container reference
    :rtype: :any:`Persistable`
    """
    # return self.__node()
    return self.__node

  @node.deleter
  def node (self):
    del self.__node

  def add_property (self, property, value):
    """
    Add a property to the :any:`Port`.

    :param property: property
    :type property: str
    :param value: property value
    :type value: str
    :return: the Port object to allow function chaining
    :rtype: :any:`Port`
    """
    self.properties[property] = value
    return self

  def has_property (self, property):
    """
    Return True if :any:`Port` has a property with given `property`.

    :param property: property
    :type property: str
    :return: has a property with given name or not
    :rtype: bool
    """
    return property in self.properties

  def del_property (self, property=None):
    """
    Remove the property from the :any:`Port`. If no property is given all the
    properties will be removed from the :any:`Port`.

    :param property: property name
    :type property: str
    :return: removed property or None
    :rtype: str or None
    """
    if property is None:
      self.properties.clear()
    else:
      return self.properties.pop(property, None)

  def get_property (self, property):
    """
    Return the value of property.

    :param property: property
    :type property: str
    :return: the value of the property
    :rtype: str
    """
    return self.properties.get(property)

  def add_metadata (self, name, value):
    """
    Add metadata with the given `name`.

    :param name: metadata name
    :type name: str
    :param value: metadata value
    :type value: str
    :return: the :any:`Port` object to allow function chaining
    :rtype: :any:`Port`
    """
    self.metadata[name] = value
    return self

  def has_metadata (self, name):
    """
    Return True if the :any:`Port` has a metadata with the given `name`.

    :param name: metadata name
    :type name: str
    :return: has metadata with given name or not
    :rtype: bool
    """
    return name in self.metadata

  def del_metadata (self, name=None):
    """
    Remove the metadata from the :any:`Port`. If no metadata is given all the
    metadata will be removed.

    :param name: name of the metadata
    :type name: str
    :return: removed metadata or None
    :rtype: str or None
    """
    if name is None:
      self.metadata.clear()
    else:
      return self.metadata.pop(name, None)

  def get_metadata (self, name):
    """
    Return the value of metadata.

    :param name: name of the metadata
    :type name: str
    :return: metadata value
    :rtype: str
    """
    return self.metadata.get(name)

  def persist (self):
    """
    Persist object.

    :return: JSON representation
    :rtype: dict
    """
    port = super(Port, self).persist()
    if self.properties:
      port["property"] = self.properties.copy()
    if self.name is not None:
      port['name'] = self.name
    if self.sap is not None:
      port['sap'] = self.sap
    if self.capability is not None:
      port['capability'] = self.capability
    if any(v is not None for v in (self.technology, self.role, self.delay,
                                   self.bandwidth, self.cost)):
      port['sap_data'] = {}
      if self.technology is not None:
        port['sap_data']['technology'] = self.technology
      if self.role is not None:
        port['sap_data']['role'] = self.role
      if any(v is not None for v in (self.delay, self.bandwidth, self.cost)):
        port['sap_data']['resources'] = {}
        if self.delay is not None:
          port['sap_data']['resources']['delay'] = self.delay
        if self.bandwidth is not None:
          port['sap_data']['resources']['bandwidth'] = self.bandwidth
        if self.cost is not None:
          port['sap_data']['resources']['cost'] = self.cost
    if any(v is not None for v in (self.controller, self.orchestrator)):
      port['control'] = {}
      if self.controller is not None:
        port['control']['controller'] = self.controller
      if self.orchestrator is not None:
        port['control']['orchestrator'] = self.orchestrator
    if any(v is not None for v in
           (self.l2, self.l4, True if self.l3 else None)):
      port['addresses'] = {}
      if self.l2 is not None:
        port['addresses']['l2'] = self.l2
      if self.l4 is not None:
        port['addresses']['l4'] = self.l4
      if len(self.l3):
        port['addresses']['l3'] = self.l3.persist()
    if self.metadata:
      port["metadata"] = self.metadata.copy()
    return port

  def load (self, data, *args, **kwargs):
    """
    Instantiate object from JSON.

    :param data: JSON data
    :type data: dict
    :return: None
    """
    super(Port, self).load(data=data)
    self.properties = OrderedDict(data.get('property', ()))
    self.sap = data.get('sap')
    self.name = data.get('name')
    self.capability = data.get('capability')
    if 'sap_data' in data:
      self.technology = data['sap_data'].get('technology')
      self.role = data['sap_data'].get('role')
      if 'resources' in data['sap_data']:
        self.delay = data['sap_data']['resources'].get('delay')
        self.bandwidth = data['sap_data']['resources'].get('bandwidth')
        self.cost = data['sap_data']['resources'].get('cost')
    else:
      self.technology = self.delay = self.bandwidth = self.cost = None
    if 'control' in data:
      self.controller = data['control'].get('controller')
      self.orchestrator = data['control'].get('orchestrator')
    else:
      self.controller = self.orchestrator = None
    if 'addresses' in data:
      self.l2 = data['addresses'].get('l2')
      self.l3.load(data=data['addresses'].get('l3', ()))
      self.l4 = data['addresses'].get('l4')
    else:
      self.l2 = self.l4 = None
    self.metadata = OrderedDict(data.get('metadata', ()))
    return self

  def __repr__ (self):
    """
    Return with specific string representation.

    :return: specific representation
    :rtype: str
    """
    return "%s(node: %s, id: %s)" % (
      self.__class__.__name__, self.node.id, self.id)


class PortContainer(Persistable):
  """
  Basic container class for ports.

  Implements a Container-like behavior for getting a Port with id:
    >>> cont = PortContainer()
    >>> ...
    >>> cont["port_id"]
  """

  def __init__ (self, container=None):
    """
    Init.

    :param container: use given container for init
    :type container: :any:`collections.Container`
    """
    self.container = container if container is not None else []

  def __getitem__ (self, id):
    """
    Return with the :any:`Port` given by ``id``.

    :param id: port id
    :type id: str or int
    :return: port object
    :rtype: :any:`Port`
    """
    for port in self.container:
      if port.id == id:
        return port
    raise KeyError("Port with id: %s is not defined in: %s!"
                   % (id, [p.id for p in self.container]))

  def __iter__ (self):
    """
    Return with an iterator over the container.

    :return: iterator
    :rtype: collection.Iterable
    """
    return iter(self.container)

  def __len__ (self):
    """
    Return the number of stored :any:`Port`.

    :return: number of ports
    :rtype: int
    """
    return len(self.container)

  def __contains__ (self, item):
    """
    Return True if port given by ``id`` is exist in the container.

    :param item: port object
    :type: :any:`Port`
    :return: found port or not
    :rtype: bool
    """
    # this type checking is important because with Port ID input the function
    # would silently return False!
    if isinstance(item, Port):
      return item in self.container
    else:
      return item in (p.id for p in self.container)

  @property
  def flowrules (self):
    """
    Return with an iterator over the flowrules sored in the ports.

    :return: iterator of flowrules
    :rtype: collections.Iterator
    """
    return chain(*[port.flowrules for port in self.container])

  def append (self, item):
    """
    Add new port object to the container.

    :param item: port object
    :type item: :any:`Port`
    :return: added object
    :rtype: :any:`Port`
    """
    self.container.append(item)
    return item

  def remove (self, item):
    """
    Remove port object from the container.

    :param item: port object
    :type item: :any:`Port`
    :return: None
    """
    try:
      return self.container.remove(item)
    except ValueError:
      return

  def clear (self):
    """
    Remove all the stored objects.

    :return: None
    """
    del self.container[:]

  def __str__ (self):
    """
    Return with string representation.

    :return: string representation
    :rtype: str
    """
    return str(self.container)

  def __repr__ (self):
    """
    Return with specific string representation.

    :return: specific representation
    :rtype: str
    """
    return str(self)

  def persist (self):
    """
    Persist object.

    :return: JSON representation
    :rtype: list
    """
    return [port.persist() for port in self.container]

  def load (self, data, *args, **kwargs):
    """
    Instantiate object from JSON.

    :param data: JSON data
    :type data: dict
    :return: None
    """
    pass


class Constraints(Persistable):
  """
  Container class for constraints.
  """

  def __init__ (self):
    super(Constraints, self).__init__()
    self.affinity = {}
    self.antiaffinity = {}
    self.variable = OrderedDict()
    self.constraint = {}

  def add_affinity (self, id, value):
    self.affinity[id] = value
    return value

  def has_affinity (self, id):
    return id in self.affinity

  def del_affinity (self, id):
    return self.affinity.pop(id, None)

  def add_antiaffinity (self, id, value):
    self.antiaffinity[id] = value
    return value

  def has_antiaffinity (self, id):
    return id in self.antiaffinity

  def del_antiaffinity (self, id):
    return self.antiaffinity.pop(id, None)

  def add_variable (self, key, id):
    self.variable[key] = id
    return id

  def has_variable (self, key):
    return key in self.variable

  def del_variable (self, key):
    return self.variable.pop(key, None)

  def add_constraint (self, id, formula):
    self.constraint[id] = formula
    return formula

  def has_constraint (self, id):
    return id in self.constraint

  def del_constraint (self, id):
    return self.constraint.pop(id, None)

  def persist (self):
    constraints = super(Constraints, self).persist()
    if self.affinity:
      constraints['affinity'] = self.affinity
    if self.antiaffinity:
      constraints['antiaffinity'] = self.antiaffinity
    if self.variable:
      constraints['variable'] = self.variable
    if self.constraint:
      constraints['constraint'] = self.constraint
    return constraints

  def load (self, data, *args, **kwargs):
    super(Constraints, self).load(data=data)
    self.affinity = data.get('affinity', OrderedDict())
    self.antiaffinity = data.get('antiaffinity', OrderedDict())
    self.variable = data.get('variable', OrderedDict())
    self.constraint = data.get('constraint', [])
    return self


class Node(Element):
  """
  Base class for different types of nodes in the NF-FG.
  """
  # Class of the contained ports
  PORT_CLASS = Port
  """Class of the contained ports"""
  # Node type constants:
  # Infrastructure node --> abstract node represents one or more physical node
  INFRA = "INFRA"
  # SAP nodes --> abstract node represents end point/ports of a service
  SAP = "SAP"
  # Network Function (NF) node --> abstract node represents a virtual function
  NF = "NF"

  def __init__ (self, type, id=None, name=None, metadata=None):
    """
    Init.

    :param type: node type
    :type type: str
    :param id: optional id
    :type id: str or int
    :param name: optional name
    :type name: str
    :param metadata: metadata related to Node
    :type metadata: dict
    :return: None
    """
    super(Node, self).__init__(id=id, type=type)
    self.name = name if name is not None else str(id)  # optional
    self.ports = PortContainer()  # list of Ports
    self.metadata = OrderedDict(metadata if metadata else {})
    self.constraints = Constraints()

  @property
  def short_name (self):
    """
    Return a generic shor name.

    :return: short name
     :rtype: str
    """
    return self.name if self.name else "id: %s" % self.id

  def flowrules (self):
    """
    Return with an iterator over the flowrules sored in the ports.

    :return: iterator of flowrules
    :rtype: collections.Iterator
    """
    return self.ports.flowrules

  def add_port (self, id=None, name=None, properties=None, sap=None,
                capability=None, technology=None, delay=None, bandwidth=None,
                cost=None, controller=None, orchestrator=None, l2=None, l4=None,
                metadata=None):
    """
    Add a port with the given params to the :any:`Node`.

    :param id: optional id
    :type id: str or int
    :param properties: supported properties of the port
    :type properties: str or iterable(str)
    :param name: optional name
    :type name: str
    :param sap: inter-domain SAP identifier
    :type sap: str
    :param capability: optional capabilities
    :type capability: str
    :param technology: supported technologies
    :type technology: str
    :param delay: delay
    :type delay: float
    :param bandwidth: bandwidth
    :type bandwidth: float
    :param cost: cost
    :type cost: str
    :param controller: controller URL
    :type controller: str
    :param orchestrator: orchestrator URL
    :type orchestrator: str
    :param l2: l2 address
    :param l2: str
    :param l4: l4 fields
    :type l4: str
    :param metadata: metadata related to Node
    :type metadata: dict
    :return: newly created and stored Port object
    :rtype: :any:`Port`
    """
    port = Port(node=self, id=id, name=name, properties=properties, sap=sap,
                capability=capability, technology=technology, delay=delay,
                bandwidth=bandwidth, cost=cost, controller=controller,
                orchestrator=orchestrator, l2=l2, l4=l4, metadata=metadata)
    self.ports.append(port)
    return port

  def del_port (self, id):
    """
    Remove the port with the given id from the Node.

    :param id: port id
    :type id: int or str
    :return: the actual Port is found and removed or not
    :rtype: bool
    """
    for port in self.ports:
      if port.id == id:
        del port.node
        return self.ports.remove(port)
    return False

  def has_port (self, id):
    """
    Return True if the :any:`Node` has a port with the given `id`.

    :param id: optional id
    :type id: str or int
    :return: has port with given id or not
    :rtype: bool
    """
    for p in self.ports:
      if p.id == id:
        return True
    return False

  def add_metadata (self, name, value):
    """
    Add metadata with the given `name`.

    :param name: metadata name
    :type name: str
    :param value: metadata value
    :type value: str
    :return: the :any:`Node` object to allow function chaining
    :rtype: :any:`Node`
    """
    self.metadata[name] = value
    return self

  def has_metadata (self, name):
    """
    Return True if the :any:`Node` has a metadata with the given `name`.

    :param name: metadata name
    :type name: str
    :return: has metadata with given name or not
    :rtype: bool
    """
    return name in self.metadata

  def del_metadata (self, name=None):
    """
    Remove the metadata from the :any:`Node`. If no metadata is given all the
    metadata will be removed.

    :param name: name of the metadata
    :type name: str
    :return: removed metadata or None
    :rtype: str or None
    """
    if name is None:
      self.metadata.clear()
    else:
      return self.metadata.pop(name, None)

  def get_metadata (self, name):
    """
    Return the value of metadata.

    :param name: name of the metadata
    :type name: str
    :return: metadata value
    :rtype: str
    """
    return self.metadata.get(name)

  def persist (self):
    """
    Persist object.

    :return: JSON representation
    :rtype: dict
    """
    node = super(Node, self).persist()
    if self.name is not None:
      node["name"] = self.name
    ports = self.ports.persist()
    if ports:
      node["ports"] = ports
    if self.metadata:
      node["metadata"] = self.metadata.copy()
    constraints = self.constraints.persist()
    if constraints:
      node['constraints'] = constraints
    return node

  def load (self, data, *args, **kwargs):
    """
    Instantiate object from JSON.

    :param data: JSON data
    :type data: dict
    :return: None
    """
    super(Node, self).load(data=data)
    self.name = data.get('name')  # optional
    for item in data.get('ports', ()):
      port = self.PORT_CLASS(node=self)
      port.load(data=item)
      self.ports.append(port)
    self.metadata = OrderedDict(data.get('metadata', ()))
    if 'constraints' in data:
      self.constraints.load(data=data['constraints'])
    return self

  def __repr__ (self):
    """
    Return with specific string representation.

    :return: specific representation
    :rtype: str
    """
    return "<|ID: %s, Type: %s --> %s|>" % (
      self.id, self.type, super(Element, self).__repr__())

  def __str__ (self):
    """
    Return with string representation.

    :return: string representation
    :rtype: str
    """
    return "%s(id:%s, type:%s)" % (self.__class__.__name__, self.id, self.type)


class Link(Element):
  """
  Base class for different types of edges in the NF-FG.
  """
  # Edge type constants:
  # Static link --> physical link between saps and infras
  STATIC = "STATIC"
  # Dynamic link --> virtual link between nfs and infras created on demand
  DYNAMIC = "DYNAMIC"
  # SG next hop --> virtual link to describe connection between elements in SG
  SG = "SG"
  # Requirement --> virtual link to define constraints between SG elements
  REQUIREMENT = "REQUIREMENT"

  def __init__ (self, src=None, dst=None, type=None, id=None):
    """
    Init.

    :param src: source port
    :type src: :any:`Port`
    :param dst: destination port
    :type dst: :any:`Port`
    :param type: link type
    :type type: str
    :param id: optional id
    :type id: str or int
    :return: None
    """
    super(Link, self).__init__(id=id, type=type)
    if (src is not None and not isinstance(src, Port)) or \
       (dst is not None and not isinstance(dst, Port)):
      raise RuntimeError("Src and dst must be Port objects!")
    # Reference to src Port object
    self.src = src  # mandatory
    # Reference to dst Port object
    self.dst = dst  # mandatory

  def persist (self):
    """
    Persist object.

    :return: JSON representation
    :rtype: dict
    """
    link = super(Link, self).persist()
    link['src_node'] = self.src.node.id
    link['src_port'] = self.src.id
    link['dst_node'] = self.dst.node.id
    link['dst_port'] = self.dst.id
    return link

  def load (self, data, container=None, *args, **kwargs):
    """
    Instantiate object from JSON.

    :param data: JSON data
    :type data: dict
    :param container: main container node
    :type container: :any:`NFFGModel`
    :return: None
    """
    if container is None:
      raise RuntimeError(
        "Container reference is not given for edge endpoint lookup!")
    super(Link, self).load(data=data)
    self.src = container.get_port(data['src_node'], data['src_port'])
    self.dst = container.get_port(data['dst_node'], data['dst_port'])
    if self.src is None:
      raise RuntimeError("Src not found with params: %s !" % data)
    if self.dst is None:
      raise RuntimeError("Dst not found with params: %s !" % data)
    return self

  def __repr__ (self):
    """
    Return with specific string representation.

    :return: specific representation
    :rtype: str
    """
    return "<|ID: %s, Type: %s, src: %s[%s], dst: %s[%s] --> %s|>" % (
      self.id, self.type, self.src.node.id, self.src.id, self.dst.node.id,
      self.dst.id, super(Element, self).__repr__())


################################################################################
# ---------- NODE AND LINK RESOURCES, ATTRIBUTES -------------------
################################################################################

class DelayMatrix(Persistable):
  """
  Delay Matrix keyed by Port IDs.
  """

  def __init__ (self):
    super(DelayMatrix, self).__init__()
    self.matrix = OrderedDict()

  def persist (self):
    res = super(DelayMatrix, self).persist()
    for k, v in self.matrix.iteritems():
      if not isinstance(v, dict):
        continue
      for kk, vv in v.iteritems():
        if k not in res:
          res[k] = OrderedDict()
        try:
          res[k][kk] = float(vv)
        except ValueError:
          res[k][kk] = vv
    return res

  def load (self, data, *args, **kwargs):
    self.matrix.update(data)
    return self

  def is_empty (self):
    return sum([len(e) for e in self.matrix]) == 0

  def add_delay (self, src, dst, delay):
    if src not in self.matrix:
      self.matrix[src] = OrderedDict()
    self.matrix[src][dst] = delay

  def get_delay (self, src, dst):
    # id-s are always string in delay matrix, because of JSON standard
    if src in self.matrix:
      if dst in self.matrix[src]:
        return self.matrix[src][dst]

  def del_delay (self, src, dst):
    # id-s are always string in delay matrix, because of JSON standard
    if src in self.matrix:
      if dst in self.matrix[src]:
        return self.matrix[src].pop(dst)

  def __contains__ (self, item):
    return item in self.matrix

  def __getitem__ (self, item):
    return self.matrix[item]

  def __iter__ (self):
    return ((src, dst, self.matrix[src][dst])
            for src in self.matrix
            for dst in self.matrix[src])


class NodeResource(Persistable):
  """
  Class for storing resource information for Nodes.
  """

  # YANG: grouping node_resource

  def __init__ (self, cpu=None, mem=None, storage=None, delay=None,
                bandwidth=None):
    """
    Init.

    :param cpu: CPU resource
    :type cpu: float
    :param mem: memory resource
    :type mem: float
    :param storage: storage resource
    :type storage: float
    :param delay: delay property of the Node
    :type delay: float
    :param bandwidth: bandwidth property of the Node
    :type bandwidth: float
    :return: None
    """
    super(NodeResource, self).__init__()
    # container: compute
    self.cpu = cpu
    self.mem = mem
    # container
    self.storage = storage
    self.delay = delay
    self.bandwidth = bandwidth

  def subtractNodeRes (self, subtrahend, maximal, link_count=1):
    """
    Subtracts the subtrahend nffg_elements.NodeResource object from the current.
    Note: only delay component is not subtracted, for now we neglect the load`s
    influence on the delay. Link count identifies how many times the bandwidth
    should be subtracted. Throw exception if any field of the 'current' would 
    exceed 'maximal' or get below zero.

    :param subtrahend: the object to be subtracted from current
    :type subtrahend: NodeResource
    :param maximal: The maximal value which must not be exceeded.
    :type maximal: NodeResource
    :param link_count: how many times the should the bandwidth component be
      subtracted.
    :type link_count: int
    :return: self resource object
    :rtype: :any:`NodeResource`
    """
    attrlist = ['cpu', 'mem', 'storage', 'bandwidth']  # delay excepted!
    if reduce(lambda a, b: a or b, (self[attr] is None for attr in attrlist)):
      raise RuntimeError("Node resource components should always be given"
                         "One of %s`s components is None" % str(self))
    if not reduce(lambda a, b: a and b,
                  (-1e-6 <= self[attr] - subtrahend[attr] <= maximal[
                    attr] + 1e-6 for attr in attrlist if
                   attr != 'bandwidth' and subtrahend[attr] is not None)):
      raise RuntimeError("Node resource got below zero, or "
                         "exceeded the maximal value!")
    if subtrahend['bandwidth'] is not None:
      if not -1e-6 <= self['bandwidth'] - link_count * subtrahend[
        'bandwidth'] <= maximal['bandwidth'] + 1e-6:
        raise RuntimeError("Internal bandwidth cannot get below "
                           "zero, or exceed the maximal value!")
    for attr in attrlist:
      k = 1
      if attr == 'bandwidth':
        k = link_count
      if subtrahend[attr] is not None:
        self[attr] -= k * subtrahend[attr]
    return self

  def persist (self):
    """
    Persist object.

    :return: JSON representation
    :rtype: dict
    """
    res = super(NodeResource, self).persist()
    if self.cpu is not None:
      res["cpu"] = self.cpu
    if self.mem is not None:
      res["mem"] = self.mem
    if self.storage is not None:
      res["storage"] = self.storage
    if self.delay is not None:
      res["delay"] = self.delay
    if self.bandwidth is not None:
      res["bandwidth"] = self.bandwidth
    return res

  def load (self, data, *args, **kwargs):
    """
    Instantiate object from JSON.

    :param data: JSON data
    :type data: dict
    :return: None
    """
    self.cpu = float(data['cpu']) if 'cpu' in data else None
    self.mem = float(data['mem']) if 'mem' in data else None
    self.storage = float(data['storage']) if 'storage' in data else None
    self.delay = float(data['delay']) if 'delay' in data else None
    self.bandwidth = float(data['bandwidth']) if 'bandwidth' in data else None
    return self

  def __getitem__ (self, item):
    """
    Return the resource attribute given by ``item``:

    :param item: attribute name
    :type item: str
    :return: attribute value
    :rtype: int or object
    """
    if hasattr(self, item):
      return getattr(self, item)
    else:
      raise KeyError(
        "%s object has no key: %s" % (self.__class__.__name__, item))

  def __setitem__ (self, key, value):
    """
    Set the resource attribute given by ``key`` with ``value``:

    :param key: attribute name
    :type key: str
    :param value: new value
    :type value: int or object
    :return: None
    """
    if hasattr(self, key):
      return setattr(self, key, value)
    else:
      raise KeyError(
        "%s object has no key: %s" % (self.__class__.__name__, key))

  def __repr__ (self):
    """
    Return with specific string representation.

    :return: specific representation
    :rtype: str
    """
    return "Resources of %s:\ncpu: %s\nmem: %s\nstorage: %s\nbandwidth: " \
           "%s\ndelay: %s" % (
             self.__class__.__name__, self.cpu, self.mem, self.storage,
             self.bandwidth, self.delay)

  def __str__ (self):
    """
    Return with string representation.

    :return: string representation
    :rtype: str
    """
    return "cpu: %s mem: %s storage: %s bandwidth: %s delay: %s" % (
      self.cpu, self.mem, self.storage, self.bandwidth, self.delay)

  def is_empty (self):
    """
    Return False if no resource value are set or 0.

    :return: resource values are set or not
    :rtype: bool
    """
    return False if any(
      (self.cpu, self.mem, self.storage, self.delay, self.bandwidth)) else True


class Flowrule(Element):
  """
  Class for storing a flowrule.
  """

  def __init__ (self, id=None, match="", action="", bandwidth=None, delay=None,
                external=False):
    """
    Init.

    :param match: matching rule
    :type match: str
    :param action: forwarding action
    :type action: str
    :param bandwidth: bandwidth
    :type bandwidth: float
    :param delay: delay
    :type delay: float
    :param external: mark the flowrule as external --> should not process
    :type external: bool
    :return: None
    """
    super(Flowrule, self).__init__(id=id, type="FLOWRULE")
    self.match = match  # mandatory
    self.action = action  # mandatory
    self.bandwidth = bandwidth
    self.delay = delay
    self.external = external

  def persist (self):
    """
    Persist object.

    :return: JSON representation
    :rtype: dict
    """
    flowrule = super(Flowrule, self).persist()
    if self.match:
      flowrule['match'] = self.match
    if self.action:
      flowrule['action'] = self.action
    if self.bandwidth:
      flowrule['bandwidth'] = self.bandwidth
    if self.delay:
      flowrule['delay'] = self.delay
    if self.external:
      flowrule['external'] = self.external
    return flowrule

  def load (self, data, *args, **kwargs):
    """
    Instantiate object from JSON.

    :param data: JSON data
    :type data: dict
    :return: None
    """
    super(Flowrule, self).load(data=data)
    self.match = data.get('match')
    self.action = data.get('action')
    self.bandwidth = float(data['bandwidth']) if 'bandwidth' in data else None
    self.delay = float(data['delay']) if 'delay' in data else None
    self.external = float(data['external']) if 'external' in data else False
    return self

  def __repr__ (self):
    """
    Return with specific string representation.

    :return: specific representation
    :rtype: str
    """
    return "Flowrule object:\nmatch: %s \naction: %s \nbandwidth: " \
           "%s \ndelay: %s \nexternal: %s" % (self.match, self.action,
                                              self.bandwidth, self.delay,
                                              self.external)

  def __str__ (self):
    """
    Return with string representation.

    :return: string representation
    :rtype: str
    """
    return "%s(match: %s, action: %s, bandwidth: %s, delay: %s, external: %s)" \
           % (self.__class__.__name__, self.match, self.action, self.bandwidth,
              self.delay, self.external)


class InfraPort(Port):
  """
  Class for storing a port of Infra Node and handles flowrules.
  """

  def __init__ (self, node, id=None, name=None, properties=None, sap=None,
                capability=None, technology=None, delay=None, bandwidth=None,
                cost=None, controller=None, orchestrator=None, l2=None, l4=None,
                metadata=None):
    """
    Init.

    :param node: container node
    :type node: :any:`Node`
    :param id: optional id
    :type id: str or int
    :param properties: supported properties of the port
    :type properties: str or iterable(str)
    :param metadata: metadata related to Node
    :type metadata: dict
    :return: None
    """
    super(InfraPort, self).__init__(node=node, id=id, name=name,
                                    properties=properties, sap=sap,
                                    capability=capability,
                                    technology=technology, delay=delay,
                                    bandwidth=bandwidth, cost=cost,
                                    controller=controller,
                                    orchestrator=orchestrator, l2=l2, l4=l4,
                                    metadata=metadata)
    self.flowrules = []

  def add_flowrule (self, match, action, bandwidth=None, delay=None, id=None,
                    external=False):
    """
    Add a flowrule with the given params to the port of an Infrastructure Node.

    :param match: matching rule
    :type match: str
    :param action: forwarding action
    :type action: str
    :param bandwidth: bandwidth
    :type bandwidth: float
    :param delay: delay
    :type delay: float
    :param id: specific id of the flowrule
    :type id: str or int
    :return: newly created and stored flowrule
    :rtype: :any:`Flowrule`
    """
    flowrule = Flowrule(id=id, match=match, action=action, bandwidth=bandwidth,
                        delay=delay, external=external)
    self.flowrules.append(flowrule)
    return flowrule

  def del_flowrule (self, id=None, match=None, action=None):
    """
    Remove the flowrule with the given id or all flowrules which match the given
    action/match parameters.

    :param id: flowrule id
    :type id: int or str
    :param match: matching rule
    :type match: str
    :param action: forwarding action
    :type action: str
    :return: the actual FlowRule is found and removed or not
    :rtype: bool
    """
    if id is not None:
      for f in self.flowrules:
        if f.id == id:
          self.flowrules.remove(f)
          return True
    else:
      deletable = []
      ret = False
      for f in self.flowrules:
        if f.match == match or f.action == action:
          deletable.append(f)
      for f in deletable:
        self.flowrules.remove(f)
        ret = True
      return ret

  def clear_flowrules (self):
    """
    Delete all the flowrules from the port.

    :return: None
    """
    del self.flowrules[:]

  def persist (self):
    """
    Persist object.

    :return: JSON representation
    :rtype: dict
    """
    port = super(InfraPort, self).persist()
    flowrules = [f.persist() for f in self.flowrules]
    if flowrules:
      port["flowrules"] = flowrules
    return port

  def load (self, data, *args, **kwargs):
    """
    Instantiate object from JSON.

    :param data: JSON data
    :type data: dict
    :return: None
    """
    super(InfraPort, self).load(data=data)
    for flowrule in data.get('flowrules', ()):
      self.add_flowrule(
        id=flowrule['id'],
        match=flowrule.get('match'),
        action=flowrule.get('action'),
        delay=float(flowrule['delay']) if 'delay' in flowrule else None,
        bandwidth=float(
          flowrule['bandwidth']) if 'bandwidth' in flowrule else None)


################################################################################
# ------------------------ NF / SAP / INFRASTRUCTURE NODES -------------------
################################################################################

class NodeNF(Node):
  """
  Network Function (NF) nodes in the graph.
  """

  def __init__ (self, id=None, name=None, func_type=None, dep_type=None,
                res=None):
    """
    Init.

    :param func_type: functional type (default: "None")
    :type func_type: str
    :param dep_type: deployment type (default: "None")
    :type dep_type: str
    :param res: optional NF resources
    :type res: :any:`NodeResource`
    :return: None
    """
    super(NodeNF, self).__init__(id=id, type=Node.NF, name=name)
    self.functional_type = func_type  # mandatory
    # container: specification
    self.deployment_type = dep_type
    self.resources = res if res is not None else NodeResource()
    # container

  def persist (self):
    """
    Persist object.

    :return: JSON representation
    :rtype: dict
    """
    node = super(NodeNF, self).persist()
    if self.functional_type is not None:
      node["functional_type"] = self.functional_type
    specification = OrderedDict()
    if self.deployment_type is not None:
      specification["deployment_type"] = self.deployment_type
    res = self.resources.persist()
    if res:
      specification["resources"] = res
    if specification:
      node["specification"] = specification
    return node

  def load (self, data, *args, **kwargs):
    """
    Instantiate object from JSON.

    :param data: JSON data
    :type data: dict
    :return: None
    """
    super(NodeNF, self).load(data=data)
    self.functional_type = data.get('functional_type')
    if 'specification' in data:
      self.deployment_type = data['specification'].get('deployment_type')
      if 'resources' in data['specification']:
        self.resources.load(data['specification']['resources'])
    return self

  def __str__ (self):
    """
    Return with string representation.

    :return: string representation
    :rtype: str
    """
    return "%s(id:%s, type:%s)" % (
      self.__class__.__name__, self.id, self.functional_type)


class NodeSAP(Node):
  """
  Class for SAP nodes in the NF-FG.
  """

  def __init__ (self, id=None, name=None, binding=None, metadata=None):
    """
    Init.

    :param id: optional id
    :type id: str or int
    :param name: optional name
    :type name: str
    :param binding: interface binding
    :type binding: str
    :param metadata: metadata related to Node
    :type metadata: dict
    :return: None
    """
    super(NodeSAP, self).__init__(id=id, type=Node.SAP, name=name,
                                  metadata=metadata)
    # Signals if the SAP is an inter-domain SAP
    self.binding = binding

  def __str__ (self):
    """
    Return with string representation.

    :return: string representation
    :rtype: str
    """
    return "SAP(id: %s, name: %s)" % (self.id, self.name)

  def __repr__ (self):
    """
    Return with specific string representation.

    :return: specific representation
    :rtype: str
    """
    return super(NodeSAP, self).__repr__()

  def persist (self):
    """
    Persist object.

    :return: JSON representation
    :rtype: dict
    """
    sap = super(NodeSAP, self).persist()
    if self.binding is not None:
      sap['binding'] = self.binding
    return sap

  def load (self, data, *args, **kwargs):
    """
    Instantiate object from JSON.

    :param data: JSON data
    :type data: dict
    :return: None
    """
    super(NodeSAP, self).load(data=data)
    self.binding = data.get('binding')
    return self


class NodeInfra(Node):
  """
  Class for infrastructure nodes in the NF-FG.
  """
  PORT_CLASS = InfraPort
  # Defined Infra types
  TYPE_BISBIS = "BiSBiS"
  TYPE_EE = "EE"  # default Execution Environment with NETCONF
  TYPE_STATIC_EE = "STATIC"  # Static EE probably will never use
  TYPE_SDN_SWITCH = "SDN-SWITCH"  # Common OVS switch - can't run NF
  # Defined domain type
  DEFAULT_DOMAIN = "VIRTUAL"

  def __init__ (self, id=None, name=None, domain=None, infra_type=None,
                supported=None, res=None, mapping_features=None):
    """
    Init.

    :param mapping_features: dict from features string to bool
    :type mapping_features: dict
    :param domain: domain of the Infrastructure Node
    :type domain: str
    :param infra_type: type of the Infrastructure Node
    :type infra_type: int or str
    :param supported: list of supported functional types
    :type supported: list
    :param res: optional Infra resources
    :type res: :any:`NodeResource`
    :return: None
    """
    super(NodeInfra, self).__init__(id=id, type=Node.INFRA, name=name)
    self.mapping_features = mapping_features if mapping_features else {}
    self.domain = domain if domain is not None else self.DEFAULT_DOMAIN
    self.infra_type = infra_type if infra_type is not None else \
      self.TYPE_BISBIS
    # Set supported types according to given param type
    if isinstance(supported, basestring):
      self.supported = [str(supported), ]
    elif isinstance(supported, Iterable):
      self.supported = [sup for sup in supported]
    elif supported is None:
      self.supported = []
      # Set resource container
    self.resources = res if res is not None else NodeResource()
    self.delay_matrix = DelayMatrix()

  def add_port (self, id=None, name=None, properties=None, sap=None,
                capability=None, technology=None, delay=None, bandwidth=None,
                cost=None, controller=None, orchestrator=None, l2=None, l4=None,
                metadata=None):
    """
    Add a port with the given params to the Infrastructure Node.

    Override the basic ``add_port()`` to use :any:`InfraPort` objects.

    Add a port with the given params to the :any:`Node`.

    :param id: optional id
    :type id: str or int
    :param properties: supported properties of the port
    :type properties: str or iterable(str)
    :param name: optional name
    :type name: str
    :param sap: inter-domain SAP identifier
    :type sap: str
    :param capability: optional capabilities
    :type capability: str
    :param technology: supported technologies
    :type technology: str
    :param delay: delay
    :type delay: float
    :param bandwidth: bandwidth
    :type bandwidth: float
    :param cost: cost
    :type cost: str
    :param controller: controller URL
    :type controller: str
    :param orchestrator: orchestrator URL
    :type orchestrator: str
    :param l2: l2 address
    :param l2: str
    :param l4: l4 fields
    :type l4: str
    :param metadata: metadata related to Node
    :type metadata: dict
    :return: newly created and stored Port object
    :rtype: :any:`InfraPort`
    """
    port = InfraPort(self, id=id, name=name, properties=properties, sap=sap,
                     capability=capability, technology=technology, delay=delay,
                     bandwidth=bandwidth, cost=cost, controller=controller,
                     orchestrator=orchestrator, l2=l2, l4=l4, metadata=metadata)
    self.ports.append(port)
    return port

  def add_supported_type (self, functional_type):
    """
    Add a supported functional type or list of types to the Infrastructure Node.

    :param functional_type: the functional type
    :type functional_type: str or list or tuple
    :return: the Node object to allow function chaining
    :rtype: :any:`NodeInfra`
    """
    if isinstance(functional_type, basestring):
      self.supported.append(functional_type)
    elif isinstance(functional_type, Iterable):
      self.supported.extend(functional_type)
    else:
      raise RuntimeError("Not supported parameter type!")
    return self

  def has_supported_type (self, functional_type):
    """
    Return true if :any:`InfraPort` object has the given `functional_type`.

    :param functional_type: functional type name
    :type functional_type: str
    :return: has the given functional type or not
    :rtype: bool
    """
    for ft in self.supported:
      if ft == functional_type:
        return True
    return False

  def del_supported_type (self, functional_type=None):
    """
    Remove the given functional type from the Infrastructure Node. If no type
    is given then all supported type will be removed.

    :param functional_type: the functional type
    :type functional_type: str
    :return: None
    """
    if functional_type is None:
      self.supported[:] = []
    else:
      self.supported.remove(functional_type)

  def has_enough_resource (self, res):
    """
    Checks whether this :any:`NodeInfra` has at least 'res' resources available.
    
    :param res: res name
    :type res: :any:`NodeResource`
    :return: has enough resource or not
    :rtype: bool
    """
    if not hasattr(self, 'availres'):
      raise RuntimeError("Available resources not yet calculated for Infra %s!"
                         " Call calculate_available_node_res function first on "
                         "the containing NFFG instance!" % self.id)
    try:
      from copy import deepcopy
      # do not do the actual subtraction!
      availres = deepcopy(self.availres)
      # throws RuntimeError if it couldn't be subtracted.
      availres.subtractNodeRes(res, self.resources)
      return True
    except RuntimeError:
      return False

  def persist (self):
    """
    Persist object.

    :return: JSON representation
    :rtype: dict
    """
    node = super(NodeInfra, self).persist()
    if self.domain is not None:
      node["domain"] = self.domain
    node["type"] = self.infra_type
    supported = [sup for sup in self.supported]
    if supported:
      node['supported'] = supported
    res = self.resources.persist()
    if res:
      node["resources"] = res
    if self.mapping_features:
      node['mapping_features'] = self.mapping_features.copy()
    if not self.delay_matrix.is_empty():
      node['delay_matrix'] = self.delay_matrix.persist()
    return node

  def load (self, data, *args, **kwargs):
    """
    Instantiate object from JSON.

    :param data: JSON data
    :type data: dict
    :return: None
    """
    super(NodeInfra, self).load(data=data)
    self.domain = data.get('domain', self.DEFAULT_DOMAIN)  # optional
    self.infra_type = data['type']
    if 'supported' in data:
      self.supported = data['supported']
    if 'resources' in data:
      self.resources.load(data['resources'])
    if 'mapping_features' in data:
      self.mapping_features = data['mapping_features']
    if 'delay_matrix' in data:
      self.delay_matrix.load(data['delay_matrix'])
    return self

  def __str__ (self):
    """
    Return with string representation.

    :return: string representation
    :rtype: str
    """
    return "Infra(id: %s, name: %s, type: %s)" % (
      self.id, self.name, self.infra_type)

  def __repr__ (self):
    """
    Return with specific string representation.

    :return: specific representation
    :rtype: str
    """
    return super(NodeInfra, self).__repr__()


################################################################################
# ---------- SG REQUIREMENTS / SG NEXT_HOPS / INFRASTRUCTURE LINKS -----------
################################################################################


class EdgeLink(Link):
  """
  Class for static and dynamic links in the NF-FG.

  Represent a static or dynamic link.
  """

  def __init__ (self, src=None, dst=None, type=None, id=None, backward=False,
                delay=None, bandwidth=None):
    """
    Init.

    :param src: source port
    :type src: :any:`Port`
    :param dst: destination port
    :type dst: :any:`Port`
    :param type: type of the link (default: Link.STATIC)
    :type type: str
    :param id: optional link id
    :type id: str or int
    :param backward: the link is a backward link compared to an another Link
    :type backward: bool
    :param delay: delay resource
    :type delay: float
    :param bandwidth: bandwidth resource
    :type bandwidth: float
    :return: None
    """
    type = type if type is not None else Link.STATIC
    super(EdgeLink, self).__init__(src=src, dst=dst, type=type, id=id)
    # Signal if the link is a backward link compared to an another existing
    # Link with the same src and dst Node
    self.backward = backward  # always False by default
    self.delay = delay  # optional
    self.bandwidth = bandwidth  # optional

  def persist (self):
    """
    Persist object.

    :return: JSON representation
    :rtype: dict
    """
    link = super(EdgeLink, self).persist()
    if self.delay is not None:
      link["delay"] = self.delay
    if self.bandwidth is not None:
      link["bandwidth"] = self.bandwidth
    if self.backward:
      link["backward"] = self.backward
    return link

  def load (self, data, container=None, *args, **kwargs):
    """
    Instantiate object from JSON.

    :param data: JSON data
    :type data: dict
    :param container: main container object
    :type container: :any:`NFFGModel`
    :return: None
    """
    if container is None:
      raise RuntimeError(
        "Container reference is not given for edge endpoint lookup!")
    for link in container.edge_links:
      if link.id == data['id']:
        raise RuntimeError("ID conflict during EdgeLink loading: %s" % link.id)
    super(EdgeLink, self).load(data=data, container=container)
    self.delay = data.get('delay')
    self.bandwidth = float(data['bandwidth']) if 'bandwidth' in data else None
    self.backward = data.get('backward', False)
    return self

  def __str__ (self):
    """
    Return with string representation.

    :return: string representation
    :rtype: str
    """
    return "EdgeLink(id: %s, src: %s[%s], dst: %s[%s], type: %s, backward: " \
           "%s, delay:%s, bandwidth: %s)" % (
             self.id, self.src.node.id, self.src.id, self.dst.node.id,
             self.dst.id, self.type, self.backward, self.delay, self.bandwidth)

  def __repr__ (self):
    """
    Return with specific string representation.

    :return: specific representation
    :rtype: str
    """
    return "<|ID: %s, Type: %s, Back: %s, src: %s[%s], dst: %s[%s] --> %s|>" % (
      self.id, self.type, self.backward, self.src.node.id, self.src.id,
      self.dst.node.id, self.dst.id, super(Element, self).__repr__())


class EdgeSGLink(Link):
  """
  Class for links of SG.

  Represent an edge between SG elements.
  """

  def __init__ (self, src=None, dst=None, id=None, flowclass=None,
                tag_info=None, delay=None, bandwidth=None):
    """
    Init.

    :param src: source port
    :type src: :any:`Port`
    :param dst: destination port
    :type dst: :any:`Port`
    :param id: optional id
    :type id: str or int
    :param flowclass: flowclass of SG next hop link a.k.a a match
    :type flowclass: str
    :param tag_info: tag info
    :type tag_info: str
    :param delay: requested delay on the SG next hop
    :type delay: float
    :param bandwidth: requested bandwidth on the SG next hop
    :type bandwidth: float
    :return: None
    """
    super(EdgeSGLink, self).__init__(src=src, dst=dst, type=Link.SG, id=id)
    self.flowclass = flowclass  # flowrule without action
    self.tag_info = tag_info
    self.delay = delay
    self.bandwidth = bandwidth

  def persist (self):
    """
    Persist object.

    :return: JSON representation
    :rtype: dict
    """
    link = super(EdgeSGLink, self).persist()
    if self.flowclass is not None:
      link["flowclass"] = self.flowclass
    if self.tag_info is not None:
      link["tag_info"] = self.tag_info
    if self.delay is not None:
      link["delay"] = self.delay
    if self.bandwidth is not None:
      link["bandwidth"] = self.bandwidth
    return link

  def load (self, data, container=None, *args, **kwargs):
    """
    Instantiate object from JSON.

    :param data: JSON data
    :type data: dict
    :param container: main container object
    :type container: :any:`NFFGModel`
    :return: None
    """
    if container is None:
      raise RuntimeError(
        "Container reference is not given for edge endpoint lookup!")
    for link in container.edge_sg_nexthops:
      if link.id == data['id']:
        raise RuntimeError(
          "ID conflict during EdgeSGLink loading: %s" % link.id)
    super(EdgeSGLink, self).load(data=data, container=container)
    self.flowclass = data.get('flowclass')
    self.tag_info = data.get('tag_info')
    self.delay = float(data['delay']) if 'delay' in data else None
    self.bandwidth = float(data['bandwidth']) if 'bandwidth' in data else None
    return self

  def __str__ (self):
    """
    Return with string representation.

    :return: string representation
    :rtype: str
    """
    return "SGLink(id: %s, src: %s[%s], dst: %s[%s], tag: %s, delay: %s, " \
           "bandwidth: %s)" % (
             self.id, self.src.node.id, self.src.id, self.dst.node.id,
             self.dst.id, self.tag_info, self.delay, self.bandwidth)


class EdgeReq(Link):
  """
  Class for constraint of networking parameters between SG elements.

  Class for requirements between arbitrary NF modes.
  """

  def __init__ (self, src=None, dst=None, id=None, delay=None, bandwidth=None,
                sg_path=None):
    """
    Init.

    :param src: source port
    :type src: :any:`Port`
    :param dst: destination port
    :type dst: :any:`Port`
    :param id: optional id
    :type id: str or int
    :param delay: delay resource
    :type delay: float
    :param bandwidth: bandwidth resource
    :type bandwidth: float
    :param sg_path: list of ids of sg_links represents end-to-end requirement
    :type sg_path: list ot tuple
    :return: None
    """
    super(EdgeReq, self).__init__(src=src, dst=dst, type=Link.REQUIREMENT,
                                  id=id)
    self.delay = delay  # optional
    self.bandwidth = bandwidth  # optional
    # Set sg_path types according to given param type
    if isinstance(sg_path, basestring):
      self.sg_path = [str(sg_path), ]
    elif isinstance(sg_path, Iterable):
      self.sg_path = [p for p in sg_path]
    elif sg_path is None:
      self.sg_path = []

  def persist (self):
    """
    Persist object.

    :return: JSON representation
    :rtype: dict
    """
    link = super(EdgeReq, self).persist()
    if self.delay is not None:
      link["delay"] = self.delay
    if self.bandwidth is not None:
      link["bandwidth"] = self.bandwidth
    sg_path = self.sg_path[:]
    if sg_path:
      link['sg_path'] = sg_path
    return link

  def load (self, data, container=None, *args, **kwargs):
    """
    Instantiate object from JSON.

    :param data: JSON data
    :type data: dict
    :param container: main container object
    :type container: :any:`NFFGModel`
    :return: None
    """
    if container is None:
      raise RuntimeError(
        "Container reference is not given for edge endpoint lookup!")
    for link in container.edge_reqs:
      if link.id == data['id']:
        raise RuntimeError("ID conflict during EdgeReq loading: %s" % link.id)
    super(EdgeReq, self).load(data=data, container=container)
    self.delay = float(data['delay']) if 'delay' in data else None
    self.bandwidth = float(data['bandwidth']) if 'bandwidth' in data else None
    if 'sg_path' in data:
      self.sg_path = data['sg_path']
    return self

  def __str__ (self):
    """
    Return with string representation.

    :return: string representation
    :rtype: str
    """
    return "ReqLink(id: %s, src: %s[%s], dst: %s[%s], path: %s, delay:%s, " \
           "bandwidth: %s)" % (
             self.id, self.src.node.id, self.src.id, self.dst.node.id,
             self.dst.id, self.sg_path, self.delay, self.bandwidth)


################################################################################
# --------========== MAIN CONTAINER STARTS HERE =========-------------
################################################################################

class NFFGParseError(RuntimeError):
  """
  Exception class for specific parsing errors.
  """
  pass


class NFFGModel(Element):
  """
  Wrapper class for a single NF-FG.

  Network Function Forwarding Graph (NF-FG) data model.
  """
  # Default version
  VERSION = "1.0"
  """Default version"""
  # Namespace
  NAMESPACE = "http://csikor.tmit.bme.hu/netconf/unify/nffg"
  """Namespace"""
  # prefix
  PREFIX = "nffg"
  """prefix"""
  # Organization
  ORGANIZATION = "BME-TMIT"
  """Organization"""
  # Description
  DESCRIPTION = "Network Function Forwarding Graph (NF-FG) data model"
  """Description"""
  # Container type
  TYPE = "NFFG"

  def __init__ (self, id=None, name=None, service_id=None, metadata=None,
                mode=None, status=None, version=None):
    """
    Init.

    :param id: optional NF-FG identifier (generated by default)
    :type id: str or int
    :param name: optional NF-FG name
    :type name: str
    :param service_id: service id this NFFG is originated from
    :type service_id: str or int
    :param version: optional version (default: 1.0)
    :type version: str
    :return: None
    """
    super(NFFGModel, self).__init__(id=id, type=self.TYPE, status=status)
    self.name = name
    self.service_id = service_id
    self.version = version if version is not None else self.VERSION
    self.metadata = OrderedDict(metadata if metadata else ())
    self.mode = mode
    self.node_nfs = []
    self.node_saps = []
    self.node_infras = []
    self.edge_links = []
    self.edge_sg_nexthops = []
    self.edge_reqs = []

  @property
  def nodes (self):
    """
    Return all the node in the Container as a list.

    :return: nodes
    :rtype: list
    """
    # shallow copy
    nodes = self.node_nfs[:]
    nodes.extend(self.node_saps)
    nodes.extend(self.node_infras)
    return nodes

  @property
  def edges (self):
    """
    Return all the edges in the Container as a list.

    :return: edges
    :rtype: list
    """
    # shallow copy
    edges = self.edge_links[:]
    edges.extend(self.edge_reqs)
    edges.extend(self.edge_sg_nexthops)
    return edges

  def get_port (self, node_id, port_id):
    """
    Return the Port reference according to the given Node and Port ids.

    :param node_id: node id
    :type node_id: str
    :param port_id: port id
    :type port_id: str
    :return: port object
    :rtype: :any:`Port`
    """
    for node in self.nodes:
      if node.id == node_id:
        for port in node.ports:
          if port.id == port_id:
            return port
    return None

  def add_nf (self, **kwargs):
    """
    Create and store a NF Node with the given parameters.

    :return: the created NF
    :rtype: :any:`NodeNF`
    """
    nf = NodeNF(**kwargs)
    for node in self.node_nfs:
      if node.id == nf.id:
        raise RuntimeError(
          "NodeNF with id: %s already exist in the container!" % node.id)
    self.node_nfs.append(nf)
    return nf

  def del_nf (self, id):
    """
    Remove the NF Node with the given id.

    :param id: NF id
    :param id: str
    :return: the actual Node is found and removed or not
    :rtype: bool
    """
    for node in self.node_nfs:
      if node.id == id:
        self.node_nfs.remove(node)
        return True

  def add_sap (self, **kwargs):
    """
    Create and store a SAP Node with the given parameters.

    :return: the created SAP
    :rtype: :any:`NodeSAP`
    """
    sap = NodeSAP(**kwargs)
    for node in self.node_saps:
      if node.id == sap.id:
        raise RuntimeError(
          "NodeNF with id: %s already exist in the container!" % node.id)
    self.node_saps.append(sap)
    return sap

  def del_sap (self, id):
    """
    Remove the SAP Node with the given id.

    :param id: SAP id
    :param id: str
    :return: the actual Node is found and removed or not
    :rtype: bool
    """
    for node in self.node_saps:
      if node.id == id:
        self.node_saps.remove(node)
        return True

  def add_infra (self, **kwargs):
    """
    Create and store an Infrastructure Node with the given parameters.

    :return: the created Infra
    :rtype: :any:`NodeInfra`
    """
    infra = NodeInfra(**kwargs)
    for node in self.node_infras:
      if node.id == infra.id:
        raise RuntimeError(
          "NodeNF with id: %s already exist in the container!" % node.id)
    self.node_infras.append(infra)
    return infra

  def del_infra (self, id):
    """
    Remove Infrastructure Node with the given id.

    :param id: Infra id
    :param id: str
    :return: the actual Node is found and removed or not
    :rtype: bool
    """
    for node in self.node_infras:
      if node.id == id:
        self.node_infras.remove(node)
        return True

  def add_link (self, src, dst, **kwargs):
    """
    Create and store a Link Edge with the given src and dst nodes.

    :param src: source node
    :type src: :any:`Node`
    :param dst:  destination node
    :type dst: :any:`Node`
    :return: the created edge
    :rtype: :any:`EdgeLink`
    """
    link = EdgeLink(src=src, dst=dst, **kwargs)
    for edge in self.edge_links:
      if edge.src.id == src.id and edge.dst.id == dst.id:
        raise RuntimeError(
          "EdgeLink with src(%s) and dst(%s) endpoints already exist in the "
          "container!" % (src.id, dst.id))
    self.edge_links.append(link)
    return link

  def del_link (self, src, dst):
    """
    Remove Link Edge with given src and dst nodes.

    :param src: source node
    :type src: :any:`Node`
    :param dst:  destination node
    :type dst: :any:`Node`
    :return: the actual Edge is found and removed or not
    :rtype: bool
    """
    for edge in self.edge_links:
      if edge.src.id == src.id and edge.dst.id == dst.id:
        self.edge_links.remove(edge)
        return True

  def add_sg_hop (self, src, dst, **kwargs):
    """
    Create and store an SG next hop Edge with the given src and dst nodes.

    :param src: source node
    :type src: :any:`Node`
    :param dst:  destination node
    :type dst: :any:`Node`
    :return: the created edge
    :rtype: :any:`EdgeSGLink`
    """
    hop = EdgeSGLink(src=src, dst=dst, **kwargs)
    for edge in self.edge_sg_nexthops:
      if edge.src.id == src.id and edge.dst.id == dst.id:
        raise RuntimeError(
          "EdgeSGLink with src(%s) and dst(%s) endpoints already exist in the "
          "container!" % (src.id, dst.id))
    self.edge_sg_nexthops.append(hop)
    return hop

  def del_sg_hop (self, src, dst):
    """
    Remove SG next hop Edge with given src and dst nodes.

    :param src: source node
    :type src: :any:`Node`
    :param dst:  destination node
    :type dst: :any:`Node`
    :return: the actual Edge is found and removed or not
    :rtype: bool
    """
    for edge in self.edge_sg_nexthops:
      if edge.src.id == src.id and edge.dst.id == dst.id:
        self.edge_sg_nexthops.remove(edge)
        return True

  def add_req (self, src, dst, **kwargs):
    """
    Create and store a Requirement Edge with the given src and dst nodes.

    :param src: source node
    :type src: :any:`Node`
    :param dst:  destination node
    :type dst: :any:`Node`
    :return: the created edge
    :rtype: :any:`EdgeReq`
    """
    req = EdgeReq(src=src, dst=dst, **kwargs)
    for edge in self.edge_reqs:
      if edge.src.id == src.id and edge.dst.id == dst.id:
        raise RuntimeError(
          "EdgeReq with src(%s) and dst(%s) endpoints already exist in the "
          "container!" % (src.id, dst.id))
    self.edge_sg_nexthops.append(req)
    return req

  def del_req (self, src, dst):
    """
    Remove Requirement Edge with given src and dst nodes.

    :param src: source node
    :type src: :any:`Node`
    :param dst:  destination node
    :type dst: :any:`Node`
    :return: the actual Edge is found and removed or not
    :rtype: bool
    """
    for edge in self.edge_reqs:
      if edge.src.id == src.id and edge.dst.id == dst.id:
        self.edge_sg_nexthops.remove(edge)
        return True

  def persist (self):
    """
    Persist object.

    :return: JSON representation
    :rtype: dict
    """
    super(NFFGModel, self).persist()
    nffg = OrderedDict(parameters=OrderedDict(id=self.id))
    if self.name is not None:
      nffg["parameters"]["name"] = self.name
    if self.service_id is not None:
      nffg["parameters"]["service_id"] = self.service_id
    nffg["parameters"]["version"] = self.version
    if self.metadata:
      nffg["parameters"]["metadata"] = self.metadata
    if self.mode:
      nffg['parameters']['mode'] = self.mode
    if self.node_nfs:
      nffg["node_nfs"] = [nf.persist() for nf in self.node_nfs]
    if self.node_saps:
      nffg["node_saps"] = [sap.persist() for sap in self.node_saps]
    if self.node_infras:
      nffg["node_infras"] = [infra.persist() for infra in self.node_infras]
    if self.edge_links:
      nffg["edge_links"] = [link.persist() for link in self.edge_links]
    if self.edge_sg_nexthops:
      nffg["edge_sg_nexthops"] = [sg.persist() for sg in self.edge_sg_nexthops]
    if self.edge_reqs:
      nffg["edge_reqs"] = [req.persist() for req in self.edge_reqs]
    return nffg

  def load (self, raw_data, *args, **kwargs):
    """
    Read the given JSON object structure and try to convert to an NF-FG
    representation as an :any:`NFFGModel`.

    :param raw_data: raw date in JSON
    :type raw_data: str
    :return: the constructed NF-FG representation
    :rtype: :any:`NFFGModel`
    """

    # Converter function to avoid unicode
    def unicode_to_str (input):
      """
      Converter function to avoid unicode.

      :param input: data part
      :type input: unicode
      :return: converted data
      :rtype: str
      """
      if isinstance(input, dict):
        return OrderedDict(
          [(unicode_to_str(key), unicode_to_str(value)) for key, value in
           input.iteritems()])
      elif isinstance(input, list):
        return [unicode_to_str(element) for element in input]
      elif isinstance(input, unicode):
        # return input.encode('utf-8').replace(' ', '_')
        return input.encode('utf-8')
      else:
        return input

    try:
      # Load from plain text
      data = json.loads(raw_data, object_hook=unicode_to_str)
      # Create container and fill container fields
      container = NFFGModel(
        id=data['parameters'].get('id'),  # mandatory
        name=data['parameters'].get('name'),  # can be None
        service_id=data['parameters'].get('service_id'),  # can be None
        metadata=data['parameters'].get('metadata'),
        mode=data['parameters'].get('mode'),
        status=data['parameters'].get('status'),
        version=data['parameters'].get('version'))  # mandatory
      # Fill Container lists
      for n in data.get('node_nfs', ()):
        container.node_nfs.append(NodeNF.parse(data=n))
      for n in data.get('node_saps', ()):
        container.node_saps.append(NodeSAP.parse(data=n))
      for n in data.get('node_infras', ()):
        container.node_infras.append(NodeInfra.parse(data=n))
      for e in data.get('edge_links', ()):
        container.edge_links.append(EdgeLink.parse(data=e, container=container))
      for e in data.get('edge_sg_nexthops', ()):
        container.edge_sg_nexthops.append(
          EdgeSGLink().parse(data=e, container=container))
      for e in data.get('edge_reqs', ()):
        container.edge_reqs.append(EdgeReq.parse(data=e, container=container))
    except KeyError as e:
      raise RuntimeError("Not a valid NFFGModel format!", str(e))
    except ValueError:
      raise NFFGParseError("Parsed data is not valid JSON!")
    return container

  def dump (self):
    """
    Dump the container in plain text based on JSON structure.

    :return: NF-FG representation as plain text
    :rtype: str
    """
    return json.dumps(self.persist(), indent=2, sort_keys=False)
